#include "backend.hpp"
#include "glm/ext/quaternion_transform.hpp"
#include "loader.hpp"
#include "types.hpp"
#include "window.hpp"
#include "../gameplay/scene_manager.hpp"
#include "../utils/math.hpp"

void GraphicsBackend::LoadResources() {
    debugCube = CreateCube();
    debugShader = Loader::LoadShaderFromGLSL("resources/shaders/flat.glsl");

    globalShaders.flat = Loader::LoadShaderFromGLSL("resources/shaders/flat.glsl");
    globalShaders.particles = Loader::LoadShaderFromGLSL("resources/shaders/particles.glsl");
    globalShaders.skeletal = Loader::LoadShaderFromGLSL("resources/shaders/skeletal.glsl");
    globalShaders.skybox = Loader::LoadShaderFromGLSL("resources/shaders/skybox.glsl");
    globalShaders.font = Loader::LoadShaderFromGLSL("resources/shaders/font.glsl");
    globalShaders.terrain = Loader::LoadShaderFromGLSL("resources/shaders/terrain.glsl");
    globalShaders.uiCircle = Loader::LoadShaderFromGLSL("resources/shaders/ui_circle.glsl");
    globalShaders.uiSquare = Loader::LoadShaderFromGLSL("resources/shaders/ui_square.glsl");

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}

void GraphicsBackend::UnloadResources() {
    DeleteShader(globalShaders.flat);
    DeleteShader(globalShaders.particles);
    DeleteShader(globalShaders.skeletal);
    DeleteShader(globalShaders.skeletal);
    DeleteShader(globalShaders.font);
    DeleteShader(globalShaders.terrain);
    DeleteShader(globalShaders.uiCircle);
    DeleteShader(globalShaders.uiSquare);

    DeleteMesh(debugCube);
    DeleteShader(debugShader);
}

Mesh GraphicsBackend::CreateCube() {
    // -- IMPORTANT -- these vertices were generated by Claude
    // Define the 8 unique vertices of a cube
    std::vector<Vertex> vertices = {
        // Front face
        {{-1.0f, -1.0f,  1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},  // 0
        {{ 1.0f, -1.0f,  1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},  // 1
        {{ 1.0f,  1.0f,  1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},  // 2
        {{-1.0f,  1.0f,  1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},  // 3

        // Back face
        {{-1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, {1.0f, 0.0f}}, // 4
        {{ 1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, {0.0f, 0.0f}}, // 5
        {{ 1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, {0.0f, 1.0f}}, // 6
        {{-1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, {1.0f, 1.0f}}, // 7

        // Left face
        {{-1.0f, -1.0f, -1.0f}, {-1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 8
        {{-1.0f, -1.0f,  1.0f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}}, // 9
        {{-1.0f,  1.0f,  1.0f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}}, // 10
        {{-1.0f,  1.0f, -1.0f}, {-1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}}, // 11

        // Right face
        {{ 1.0f, -1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},  // 12
        {{ 1.0f, -1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}},  // 13
        {{ 1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},  // 14
        {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}},  // 15

        // Top face
        {{-1.0f,  1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},  // 16
        {{ 1.0f,  1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},  // 17
        {{ 1.0f,  1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},  // 18
        {{-1.0f,  1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},  // 19

        // Bottom face
        {{-1.0f, -1.0f, -1.0f}, {0.0f, -1.0f, 0.0f}, {0.0f, 0.0f}}, // 20
        {{ 1.0f, -1.0f, -1.0f}, {0.0f, -1.0f, 0.0f}, {1.0f, 0.0f}}, // 21
        {{ 1.0f, -1.0f,  1.0f}, {0.0f, -1.0f, 0.0f}, {1.0f, 1.0f}}, // 22
        {{-1.0f, -1.0f,  1.0f}, {0.0f, -1.0f, 0.0f}, {0.0f, 1.0f}}  // 23
    };

    // Define indices for the 6 faces (2 triangles per face)
    std::vector<unsigned int> indices = {
        // Front face
        0, 1, 2,
        2, 3, 0,

        // Back face
        5, 4, 7,
        7, 6, 5,

        // Left face
        8, 9, 10,
        10, 11, 8,

        // Right face
        12, 13, 14,
        14, 15, 12,

        // Top face
        16, 17, 18,
        18, 19, 16,

        // Bottom face
        20, 21, 22,
        22, 23, 20
    };

    unsigned int vao, vbo, ebo;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glGenBuffers(1, &ebo);

    glBindVertexArray(vao);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, position));
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, normal));
    glEnableVertexAttribArray(1);

    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, uv));
    glEnableVertexAttribArray(2);

    glBindVertexArray(0);

    return Mesh(vao, vbo, ebo, vertices.size(), indices.size());
}

Mesh GraphicsBackend::CreateQuad() {
    std::vector<Vertex> vertices = {
        {{-1.0f, -1.0f,  0.0}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},  // 0
        {{ 1.0f, -1.0f,  0.0}, {0.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},  // 1
        {{ 1.0f,  1.0f,  0.0}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},  // 2
        {{-1.0f,  1.0f,  0.0}, {0.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},  // 3
    };

    std::vector<unsigned int> indices = {
        // Front face
        0, 1, 2,
        2, 3, 0,
    };

    unsigned int vao, vbo, ebo;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glGenBuffers(1, &ebo);

    glBindVertexArray(vao);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, position));
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, normal));
    glEnableVertexAttribArray(1);

    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, uv));
    glEnableVertexAttribArray(2);

    glBindVertexArray(0);

    return Mesh(vao, vbo, ebo, vertices.size(), indices.size());
}

void GraphicsBackend::UpdateMeshVertices(Mesh& mesh, Vertex* vertices, int numVertices, unsigned int* indices, int numIndices) {
    glBindBuffer(GL_ARRAY_BUFFER, mesh.vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * numVertices, vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.ebo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(unsigned int) * numIndices, indices, GL_STATIC_DRAW);

    mesh.vertexCount = numVertices;
    mesh.indexCount = numIndices;
}

void GraphicsBackend::UploadMeshData(unsigned int& vao, unsigned int& vbo, unsigned int& ebo, std::vector<Vertex> vertices, std::vector<unsigned int> indices) {
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glGenBuffers(1, &ebo);

    glBindVertexArray(vao);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, position));
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, normal));
    glEnableVertexAttribArray(1);

    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, uv));
    glEnableVertexAttribArray(2);

    glVertexAttribIPointer(3, 1, GL_UNSIGNED_INT, sizeof(Vertex), (void*)offsetof(Vertex, boneID));
    glEnableVertexAttribArray(3);

    glBindVertexArray(0);
}

void GraphicsBackend::BeginDrawSkeletalMesh(SkeletalMesh& mesh, Shader& shader, Camera& camera, Transform& transform) {
    glUseProgram(shader.programID);

    glBindVertexArray(mesh.vao);

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    glEnableVertexAttribArray(3);

    //vertex uniforms
    UploadShaderUniformMat4(shader, camera.GetProjectionMatrix(), "uProjection");
    // -- IMPORTANT -- calculating view and transform on CPU prevents the floating poij
    glm::mat4 transformMatrix = transform.GetMatrix();
    UploadShaderUniformMat4(shader, camera.GetViewMatrix() * transformMatrix, "uViewTransform");
    UploadShaderUniformMat4(shader, transformMatrix, "uTransform");

    for(size_t i = 0; i < mesh.skeleton.bones.size(); i++) {
        UploadShaderUniformMat4(shader, mesh.skeleton.cachedGlobalBoneTransforms[i] * mesh.skeleton.bones[i].inverseBindMatrix, "uJointTransforms[" + std::to_string(mesh.skeleton.bones[i].id) + "]");
    }

    //fragment uniforms
    UploadShaderUniformFloat(shader, mesh.material.alpha, "uAlpha");
    UploadShaderUniformVec3(shader, mesh.material.albedo, "uAlbedo");
    UploadShaderUniformVec3(shader, mesh.material.shadowColor, "uShadowColor");
}

void GraphicsBackend::EndDrawSkeletalMesh(Mesh& mesh) {
    glDrawElements(GL_TRIANGLES, mesh.indexCount, GL_UNSIGNED_INT, 0);

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);

    glBindVertexArray(0);
    glUseProgram(0);
}

void GraphicsBackend::BeginDrawMesh(Mesh& mesh, Shader& shader, Camera& camera, Transform& transform) {
    glUseProgram(shader.programID);

    glBindVertexArray(mesh.vao);

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);

    //vertex uniforms
    glm::mat4 transformMatrix = transform.GetMatrix();
    UploadShaderUniformMat4(shader, camera.GetProjectionMatrix(), "uProjection");
    UploadShaderUniformMat4(shader, camera.GetViewMatrix() * transformMatrix, "uViewTransform");
    UploadShaderUniformMat4(shader, transformMatrix, "uTransform");

    //fragment uniforms
    UploadShaderUniformFloat(shader, mesh.material.alpha, "uAlpha");
    UploadShaderUniformVec3(shader, mesh.material.albedo, "uAlbedo");
    UploadShaderUniformVec3(shader, mesh.material.shadowColor, "uShadowColor");
}

void GraphicsBackend::EndDrawMesh(Mesh& mesh) {
    glDrawElements(GL_TRIANGLES, mesh.indexCount, GL_UNSIGNED_INT, 0);

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);

    glBindVertexArray(0);
    glUseProgram(0);
}

void GraphicsBackend::BeginDrawMeshInstanced(Mesh &mesh, Shader &shader, Camera &camera, Transform* transforms, size_t numParticles) {
    glUseProgram(shader.programID);

    glBindVertexArray(mesh.vao);

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);

    //vertex uniforms
    UploadShaderUniformMat4(shader, camera.GetProjectionMatrix(), "uProjection");
    glm::mat4 cameraView = camera.GetViewMatrix();
    for(size_t i = 0; i < numParticles; i++) {
        glm::mat4 transformMatrix = transforms[i].GetMatrix();
        UploadShaderUniformMat4(shader, cameraView * transformMatrix, "uViewTransforms[" + std::to_string(i) + "]");
        UploadShaderUniformMat4(shader, transformMatrix, "uTransforms[" + std::to_string(i) + "]");
    }

    //fragment uniforms
    UploadShaderUniformFloat(shader, mesh.material.alpha, "uAlpha");
    UploadShaderUniformVec3(shader, mesh.material.albedo, "uAlbedo");
    UploadShaderUniformVec3(shader, mesh.material.shadowColor, "uShadowColor");
}

void GraphicsBackend::EndDrawMeshInstanced(Mesh &mesh, size_t numParticles) {
    glDrawElementsInstanced(GL_TRIANGLES, mesh.indexCount, GL_UNSIGNED_INT, 0, numParticles);

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);

    glBindVertexArray(0);
    glUseProgram(0);
}

void GraphicsBackend::BeginDrawMesh2D(Mesh &mesh, Shader &shader, glm::vec2 &screenPosition, glm::vec2 &scale, float rotation, bool stretchWithAspectRatio) {
    glUseProgram(shader.programID);

    glBindVertexArray(mesh.vao);

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);

    Transform t = Transform();
    t.position.x = screenPosition.x;
    t.position.y = screenPosition.y;
    t.position.z = -1.0f;
    t.scale.x = scale.x * (stretchWithAspectRatio ? WindowManager::aspect : 1.0f);
    t.scale.y = scale.y;
    t.rotation = glm::rotate(t.rotation, glm::radians(rotation), GLOBAL_FORWARD);

    //vertex uniforms
    UploadShaderUniformMat4(shader, t.GetMatrix(), "uTransform");
    UploadShaderUniformMat4(shader, WindowManager::GetUIOrthographicMatrix(), "uProjection");

    //fragment uniforms
    UploadShaderUniformVec3(shader, mesh.material.albedo, "uAlbedo");
    UploadShaderUniformVec3(shader, mesh.material.shadowColor, "uShadowColor");
}

void GraphicsBackend::EndDrawMesh2D(Mesh &mesh) {
    glDrawElements(GL_TRIANGLES, mesh.indexCount, GL_UNSIGNED_INT, 0);

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);

    glBindVertexArray(0);
    glUseProgram(0);
}

void GraphicsBackend::DrawSkybox(Skybox &skybox, Camera& camera) {
    glUseProgram(skybox.shader->programID);

    glBindVertexArray(skybox.mesh.vao);

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);

    //vertex uniforms
    UploadShaderUniformMat4(*skybox.shader, camera.GetProjectionMatrix(), "uProjection");
    UploadShaderUniformMat4(*skybox.shader, glm::mat4(glm::mat3(camera.GetViewMatrix())), "uView");

    //fragment uniforms
    UploadShaderUniformVec3(*skybox.shader, static_cast<glm::vec3>(skybox.horizonColor.value), "uHorizonColor");
    UploadShaderUniformVec3(*skybox.shader, static_cast<glm::vec3>(skybox.skyColor.value), "uSkyColor");
    UploadShaderUniformVec3(*skybox.shader, SceneManager::currentScene->environment.sunColor, "uSunColor");
    UploadShaderUniformVec3(*skybox.shader, SceneManager::currentScene->environment.sunDirection, "uSunDirection");
    UploadShaderUniformFloat(*skybox.shader, SceneManager::currentScene->environment.sunRadius, "uSunRadius");

    glDrawElements(GL_TRIANGLES, skybox.mesh.indexCount, GL_UNSIGNED_INT, 0);

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);

    glBindVertexArray(0);
    glUseProgram(0);
}

void GraphicsBackend::DrawDebugCube(Camera& camera, Transform& transform) {
    BeginDrawMesh(debugCube, debugShader, camera, transform);
    EndDrawMesh(debugCube);
}
