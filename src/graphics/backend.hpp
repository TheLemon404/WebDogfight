#pragma once

#include "glm/ext/matrix_float4x4.hpp"
#include "glm/ext/matrix_transform.hpp"
#include "glm/ext/vector_float3.hpp"
#include "glm/gtc/type_ptr.hpp"
#include "types.hpp"
#include "../io/files.hpp"

#include <cstring>
#include <sstream>

#ifdef __EMSCRIPTEN__
#include <GLES3/gl3.h>
#else
#include <glad/glad.h>
#endif

#include <GLFW/glfw3.h>
#include <string>
#include <iostream>

enum ShaderReadMode {
    VERTEX,
    FRAGMENT
};

class GraphicsBackend {
    static void SplitShaderSource(const std::string& shaderSource, std::string& vertexSource, std::string& fragmentSource) {
            enum class Mode { NONE, VERTEX, FRAGMENT };
            std::istringstream stream(shaderSource);
            std::string line;
            Mode mode = Mode::NONE;

            while (std::getline(stream, line)) {
                // Strip CR (Windows)
                if (!line.empty() && line.back() == '\r')
                    line.pop_back();

                // Strip UTF-8 BOM
                if (line.size() >= 3 &&
                    (unsigned char)line[0] == 0xEF &&
                    (unsigned char)line[1] == 0xBB &&
                    (unsigned char)line[2] == 0xBF) {
                    line.erase(0, 3);
                }

                if (line == "#vertex") {
                    mode = Mode::VERTEX;
                    continue;
                }
                if (line == "#fragment") {
                    mode = Mode::FRAGMENT;
                    continue;
                }

                if (mode == Mode::VERTEX)
                    vertexSource += line + '\n';
                else if (mode == Mode::FRAGMENT)
                    fragmentSource += line + '\n';
            }

            if (vertexSource.empty() || fragmentSource.empty()) {
                throw std::runtime_error(
                    "Invalid shader source, missing #vertex or #fragment");
            }
    }

    public:
    static Shader CreateShader(const std::string resourcePath) {
        std::string shaderSource = Files::ReadResource(resourcePath);
        std::string vertexSource = "";
        std::string fragmentSource = "";
        SplitShaderSource(shaderSource, vertexSource, fragmentSource);

        unsigned int vertexShaderID = glCreateShader(GL_VERTEX_SHADER);
        unsigned int fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);
        unsigned int programID = glCreateProgram();
        char* vSource = vertexSource.data();
        char* fSource = fragmentSource.data();

        int success;
        char infoLog[512];
        glGetShaderiv(vertexShaderID, GL_COMPILE_STATUS, &success);
        glShaderSource(vertexShaderID, 1, &vSource, NULL);
        glCompileShader(vertexShaderID);
        glGetShaderiv(vertexShaderID, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertexShaderID, 512, NULL, infoLog);
            std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
        }

        glGetShaderiv(fragmentShaderID, GL_COMPILE_STATUS, &success);
        glShaderSource(fragmentShaderID, 1, &fSource, NULL);
        glCompileShader(fragmentShaderID);
        glGetShaderiv(fragmentShaderID, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragmentShaderID, 512, NULL, infoLog);
            std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
        }

        glAttachShader(programID, vertexShaderID);
        glAttachShader(programID, fragmentShaderID);
        glLinkProgram(programID);
        glGetProgramiv(programID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(programID, 512, NULL, infoLog);
            std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
        }

        glDeleteShader(vertexShaderID);
        glDeleteShader(fragmentShaderID);

        return Shader(programID);
    }

    static Mesh CreateCube() {
        // -- IMPORTANT -- these vertices were generated by Claude
        // Define the 8 unique vertices of a cube
        std::vector<Vertex> vertices = {
            // Front face
            {{-0.5f, -0.5f,  0.5f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},  // 0
            {{ 0.5f, -0.5f,  0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},  // 1
            {{ 0.5f,  0.5f,  0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},  // 2
            {{-0.5f,  0.5f,  0.5f}, {0.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},  // 3

            // Back face
            {{-0.5f, -0.5f, -0.5f}, {0.0f, 0.0f, -1.0f}, {1.0f, 0.0f}}, // 4
            {{ 0.5f, -0.5f, -0.5f}, {0.0f, 0.0f, -1.0f}, {0.0f, 0.0f}}, // 5
            {{ 0.5f,  0.5f, -0.5f}, {0.0f, 0.0f, -1.0f}, {0.0f, 1.0f}}, // 6
            {{-0.5f,  0.5f, -0.5f}, {0.0f, 0.0f, -1.0f}, {1.0f, 1.0f}}, // 7

            // Left face
            {{-0.5f, -0.5f, -0.5f}, {-1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 8
            {{-0.5f, -0.5f,  0.5f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}}, // 9
            {{-0.5f,  0.5f,  0.5f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}}, // 10
            {{-0.5f,  0.5f, -0.5f}, {-1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}}, // 11

            // Right face
            {{ 0.5f, -0.5f,  0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},  // 12
            {{ 0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}},  // 13
            {{ 0.5f,  0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},  // 14
            {{ 0.5f,  0.5f,  0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}},  // 15

            // Top face
            {{-0.5f,  0.5f,  0.5f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},  // 16
            {{ 0.5f,  0.5f,  0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},  // 17
            {{ 0.5f,  0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},  // 18
            {{-0.5f,  0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},  // 19

            // Bottom face
            {{-0.5f, -0.5f, -0.5f}, {0.0f, -1.0f, 0.0f}, {0.0f, 0.0f}}, // 20
            {{ 0.5f, -0.5f, -0.5f}, {0.0f, -1.0f, 0.0f}, {1.0f, 0.0f}}, // 21
            {{ 0.5f, -0.5f,  0.5f}, {0.0f, -1.0f, 0.0f}, {1.0f, 1.0f}}, // 22
            {{-0.5f, -0.5f,  0.5f}, {0.0f, -1.0f, 0.0f}, {0.0f, 1.0f}}  // 23
        };

        // Define indices for the 6 faces (2 triangles per face)
        std::vector<unsigned int> indices = {
            // Front face
            0, 1, 2,
            2, 3, 0,

            // Back face
            5, 4, 7,
            7, 6, 5,

            // Left face
            8, 9, 10,
            10, 11, 8,

            // Right face
            12, 13, 14,
            14, 15, 12,

            // Top face
            16, 17, 18,
            18, 19, 16,

            // Bottom face
            20, 21, 22,
            22, 23, 20
        };

        unsigned int vao, vbo, ebo;
        glGenVertexArrays(1, &vao);
        glGenBuffers(1, &vbo);
        glGenBuffers(1, &ebo);

        glBindVertexArray(vao);

        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, position));
        glEnableVertexAttribArray(0);

        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, normal));
        glEnableVertexAttribArray(1);

        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, uv));
        glEnableVertexAttribArray(2);

        glBindVertexArray(0);

        return Mesh(vao, vbo, ebo, vertices.size(), indices.size());
    }

    static void UploadMeshData(unsigned int& vao, unsigned int& vbo, unsigned int& ebo, std::vector<Vertex> vertices, std::vector<unsigned int> indices) {
        glGenVertexArrays(1, &vao);
        glGenBuffers(1, &vbo);
        glGenBuffers(1, &ebo);

        glBindVertexArray(vao);

        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, position));
        glEnableVertexAttribArray(0);

        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, normal));
        glEnableVertexAttribArray(1);

        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, uv));
        glEnableVertexAttribArray(2);

        glBindVertexArray(0);
    }

    static void UploadShaderUniformMat4(Shader& shader, const glm::mat4& matrix, const char* var) {
        GLint location = glGetUniformLocation(shader.programID, var);
        glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(matrix));
    }

    static void UploadShaderUniformVec3(Shader& shader, const glm::vec3& vector, const char* var) {
        GLint location = glGetUniformLocation(shader.programID, var);
        glUniform3fv(location, 1, glm::value_ptr(vector));
    }

    static void UploadShaderUniformVec2(Shader& shader, const glm::vec2& vector, const char* var) {
        GLint location = glGetUniformLocation(shader.programID, var);
        glUniform2fv(location, 1, glm::value_ptr(vector));
    }

    static void UploadShaderUniformFloat(Shader& shader, const float val, const char* var) {
        GLint location = glGetUniformLocation(shader.programID, var);
        glUniform1f(location, val);
    }

    static void UploadShaderUniformInt(Shader& shader, const int val, const char* var) {
        GLint location = glGetUniformLocation(shader.programID, var);
        glUniform1i(location, val);
    }

    static void SetBackfaceCulling(bool value) {
        value ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE);
    }

    static void SetDepthTest(bool value) {
        value ? glEnable(GL_DEPTH_TEST) : glDisable(GL_DEPTH_TEST);
    }

    static void BeginDrawMesh(Mesh& mesh, Shader& shader, Camera& camera, Transform& transform) {
        glUseProgram(shader.programID);

        glBindVertexArray(mesh.vao);

        glEnableVertexAttribArray(0);
        glEnableVertexAttribArray(1);
        glEnableVertexAttribArray(2);

        UploadShaderUniformMat4(shader, camera.GetProjectionMatrix(), "uProjection");
        UploadShaderUniformMat4(shader, camera.GetViewMatrix(), "uView");
        UploadShaderUniformMat4(shader, transform.GetMatrix(), "uTransform");
    }

    static void EndDrawMesh(Mesh& mesh) {
        glDrawElements(GL_TRIANGLES, mesh.indexCount, GL_UNSIGNED_INT, 0);

        glDisableVertexAttribArray(0);
        glDisableVertexAttribArray(1);
        glDisableVertexAttribArray(2);

        glBindVertexArray(0);
        glUseProgram(0);
    }

    static void ResetState(int viewportWidth, int viewportHeight) {
       	glViewport(0, 0, viewportWidth, viewportHeight);
        float val = 25.5 / 255.0;
        glClearColor(val, val, val, 1.0);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
};
